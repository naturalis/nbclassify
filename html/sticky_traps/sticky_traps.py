#######################################################################
# The python code for analysing sticky traps with the web application.#
# This code is created for Naturalis Biodiversity Center, Leiden.     #
# Latest update 1-7-18.                                               #
#######################################################################


# Importing useful packages.
import logging
import mimetypes
import os
import common
import cv2
import numpy as np
import yaml
import imgpheno


# List to hold the images.
image_list = []


# Not needed when running on web application.
def main():
    pass


# Returns the output, nocorners-error message and noproperties-error message to the views.py web application file.
def analyse_photo(img):
    contours, trap, nocorners = find_insects(img)
    output, noproperties = run_analysis(contours, img)
    return output, nocorners, noproperties


# Returns a list of all images present in the directory 'path'. Returns an error message when no images are found.
def get_image_paths(path):
    if not os.path.exists(path):
        logging.error("Cannot open %s (No such file or directory)", path)
        return 1

    images = []

    for item in os.listdir(path):
        imgpath = os.path.join(path, item)
        if os.path.isfile(imgpath):
            mime = mimetypes.guess_type(imgpath)[0]
            if mime and mime.startswith('image'):
                images.append(imgpath)

    if len(images) == 0:
        logging.error("No images found in %s", path)
        return 1
    return images


# Calls in different functions to analyse the image. It transforms the perspective of the image and draws the contours
# of the insects on the image. When analysis of an image is not possible it will return a string with an error message
# as a result for that particular image.
def find_insects(img_file):
    nocorners = False
    img = read_img(img_file)
    # Converts to HSV colourspace for trap roi selection.
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    # Calls the function that detects the trap based on the HSV image.
    mask = hsv_threshold(hsv)
    # Finds the four corners based on an approximation of the contour of the mask.
    corners = imgpheno.find_corners(mask)
    width = 4 * yml.trap_dimensions.Trap_width
    height = 4 * yml.trap_dimensions.Trap_height
    points_new = np.array([[0, 0], [width, 0], [0, height], [width, height]], np.float32)
    # Resizes the image.
    trap = imgpheno.perspective_transform(img, corners, points_new)
    # This code returns None for the contours, in case not exactly 4 were returned.
    if trap is None:
        nocorners = True
        contours = None
        trap = None
    # Now the program finds the insects present on the trap.
    else:
        nocorners = False
        if yml.edges_to_crop:
            trap = crop_image(trap)
        # Selects the channel with the highest contrast.
        r_channel = trap[:, :, 2]
        image_list.append(trap)
        contours = find_contours(r_channel)

        contour_img = trap.copy()
        cv2.drawContours(contour_img, contours, -1, (0, 0, 255), -1)
        image_list.append(contour_img)

    return contours, trap, nocorners


# Reads the images into an array generated by opencv2, the image is also resized if it is to large.
def read_img(path):
    img = cv2.imread(path, cv2.IMREAD_COLOR)
    perim = sum(img.shape[:2])
    if perim > 1000:
        ref = float(1000) / perim
        img = cv2.resize(img, None, fx=ref, fy=ref)
    return img


# Uses the colour of the trap to detect the outer contour of the trap.
def hsv_threshold(img):
    # Knowing which HSV colour code to use can be calculated below by giving a BGR colour code, this will return a
    # HSV colour code. Specified below is the colour blue. To specify the lower and upper HSV colour codes use lower =
    # [-10, 100, 100] and upper = [+10, 255, 255] respectively.
    #
    # colour = np.uint8([[[255, 0, 0]]])
    # hsv_colour= cv2.cvtColor(colour, cv2.COLOR_BGR2HSV)
    # print(hsv_colour)
    # This will give [120, 255, 255]

    lower_yellow = np.array([15, 100, 100])
    upper_yellow = np.array([45, 255, 255])
    mask = cv2.inRange(img, lower_yellow, upper_yellow)
    return mask


# Returns all contours found in an image using findContours using adaptive thresholding and a tree retrieval mode.
def find_contours(image):
    thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 41, 22)
    # Finds the contours in the mask of the thresholded image.
    _, contours, _ = cv2.findContours(thresh.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    return contours


# Crops the image if set in the YAML file.
def crop_image(img):
    short_edge = yml.cropping_width.along_short_edges * 4
    long_edge = yml.cropping_width.along_long_edges * 4
    width, height = img.shape[0:2]
    roi = img[short_edge: width - short_edge, long_edge: height - long_edge]
    return roi


# Uses the detected contours of the insects to determine the size and count the number of insects found for each size
# class. Returns the output of these results.
def run_analysis(contours, filename):
    if contours == None:
        output = ""
        noproperties = False
    else:
        properties = imgpheno.contour_properties(contours, ('Area', 'MajorAxisLength',))
        if properties is None:
            noproperties = True
            output = ""
        else:
            properties = imgpheno.contour_properties(contours, ('Area', 'MajorAxisLength',))
            major_axes = [i['MajorAxisLength'] for i in properties]
            smaller_than_4 = [i for i in major_axes if 4 <= i < 15]
            between_4_and_10 = [i for i in major_axes if 15 <= i < 38]
            larger_than_10 = [i for i in major_axes if 38 <= i < 45]

            areas = [i['Area'] for i in properties]
            average_area = np.mean(areas)
            number_of_insects = (len(smaller_than_4) + len(between_4_and_10) + len(larger_than_10))

            results = """%s \t %s \t %s \t %s \t %s
                """ % (filename, number_of_insects, len(smaller_than_4),
                       len(between_4_and_10), len(larger_than_10))
            noproperties = False
    return output, noproperties


# Opens the YAML file to create a DictObject of the settings that were set in the YAML file. Returns an error message if
# the YAML file cannot be found.
def open_yaml(path):
    if not os.path.isfile(path):
        logging.error("Cannot open %s (no such file)" % path)
        return None

    f = open(path, 'r')
    yml = yaml.load(f)
    yml = common.DictObject(yml)
    f.close()

    return yml


# Variable creation for the YAML file.
yml = open_yaml(os.path.join(os.path.dirname(__file__),"sticky_traps.yml"))


if __name__ == "__main__":
    main()
